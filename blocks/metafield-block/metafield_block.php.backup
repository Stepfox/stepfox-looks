<?php
/**
 * Metafield Block
 * Displays custom fields and metadata with proper security measures
 * 
 * @package Examiner
 * @since 1.0.0
 */

// Prevent direct access
if (!defined('ABSPATH')) {
    exit;
}

// Include render function with security check
$render_file = STEPFOX_LOOKS_PATH . 'blocks/metafield-block/metafield_block_html.php';
if (file_exists($render_file)) {
    require_once $render_file;
}


/**
 * Query for Gutenberg blocks with proper sanitization
 * 
 * @param array $attributes Block attributes
 * @return WP_Query|null Query object or null if invalid
 */
function examiner_query_for_gutenberg($attributes)
{
    // Validate and sanitize attributes
    if (!is_array($attributes) || empty($attributes['source'])) {
        return null;
    }
    
    if (sanitize_text_field($attributes['source']) === 'posts') {
        $number = isset($attributes['post_count']) ? absint($attributes['post_count']) : 5;
        $number = min($number, 50); // Limit to prevent abuse
        
        $args = array('posts_per_page' => $number);

        // Sanitize taxonomy and term
        if (!empty($attributes['term']) && !empty($attributes['taxonomy'])) {
            $taxonomy = sanitize_text_field($attributes['taxonomy']);
            $term = sanitize_text_field($attributes['term']);
            
            if (taxonomy_exists($taxonomy)) {
                $args['tax_query'] = array(array(
                    'taxonomy' => $taxonomy, 
                    'field' => 'slug', 
                    'terms' => array($term)
                ));
            }
        }

        // Sanitize post type
        $post_type = isset($attributes['post_type']) ? sanitize_text_field($attributes['post_type']) : 'post';
        if (post_type_exists($post_type)) {
            $args['post_type'] = $post_type;
        }
        
        $args['offset'] = isset($attributes['offset_posts']) ? absint($attributes['offset_posts']) : 0;
        $args['order'] = isset($attributes['order']) && in_array($attributes['order'], array('ASC', 'DESC')) ? $attributes['order'] : 'DESC';

        if (!empty($attributes['orderby'])) {
            switch ($attributes['orderby']) {
                case 'date':
                case 'title':
                case 'menu_order':
                case 'rand':
                    $args['orderby'] = sanitize_text_field($attributes['orderby']);
                    break;
                case 'meta_value_num':
                    if (!empty($attributes['meta_key'])) {
                        $args['orderby'] = 'meta_value_num';
                        $args['meta_key'] = sanitize_text_field($attributes['meta_key']);
                    }
                    break;
                default:
                    $args['orderby'] = 'date';
            }
        } else {
            $args['orderby'] = 'date';
        }

        return new WP_Query($args);
    }

    return null;
}


/**
 * Fixed query object for Gutenberg blocks
 */
function query_object_for_gutenberg_query()
{
    error_log("METAFIELD: query_object_for_gutenberg_query function called");
    
    try {
        // Get all post types safely
        $all_types = get_post_types(array('public' => true), 'objects');
        
        // Get template parts separately and safely
        $template_part_types = get_post_types(array(), 'objects');
        if (isset($template_part_types['wp_template_part'])) {
            $all_types['wp_template_part'] = $template_part_types['wp_template_part'];
        }
        
        // Initialize all arrays to prevent undefined variable errors
        $fields = [];
        $post_types = [];
        $all_terms = [];
        $taxonomies = [];
        $all_posts = [];
        $manual_selection = [];

        foreach ($all_types as $post_type) {
            if ($post_type->name === 'attachment') {
                continue; // Skip attachments
            }
            
            $post_types[] = array(
                'label' => $post_type->label,
                'value' => $post_type->name
            );

            // Add default fields that are always available for any post type
            $fields[$post_type->name] = [];
            $fields[$post_type->name][] = ["value" => "counter", "label" => "ðŸ“Š counter (built-in)"];
            $fields[$post_type->name][] = ["value" => "post_title", "label" => "ðŸ“ post_title (built-in)"];
            $fields[$post_type->name][] = ["value" => "post_content", "label" => "ðŸ“„ post_content (built-in)"];
            $fields[$post_type->name][] = ["value" => "post_excerpt", "label" => "ðŸ“‹ post_excerpt (built-in)"];
            $fields[$post_type->name][] = ["value" => "featured_image", "label" => "ðŸ–¼ï¸ featured_image (built-in)"];
            $fields[$post_type->name][] = ["value" => "month", "label" => "ðŸ“… month (built-in)"];
            $fields[$post_type->name][] = ["value" => "permalink", "label" => "ðŸ”— permalink (built-in)"];

            // Get registered meta fields for this specific post type
            $registered_meta = get_registered_meta_keys('post', $post_type->name);
            foreach($registered_meta as $meta_key => $meta_config) {
                // Only add if it's meant to be shown in REST/editor and not an internal field
                if ((!empty($meta_config['show_in_rest']) || !empty($meta_config['public'])) && 
                    substr($meta_key, 0, 1) !== '_' && substr($meta_key, 0, 6) !== 'field_') {
                    $fields[$post_type->name][] = ['value' => $meta_key, 'label' => 'âš™ï¸ ' . $meta_key . ' (registered)'];
                }
            }

            // Get ACF fields if ACF is active
            if (function_exists('acf_get_field_groups')) {
                $field_groups = acf_get_field_groups(array('post_type' => $post_type->name));
                foreach ($field_groups as $field_group) {
                    $acf_fields = acf_get_fields($field_group['key']);
                    if ($acf_fields) {
                        foreach ($acf_fields as $field) {
                            $fields[$post_type->name][] = [
                                'value' => $field['name'],
                                'label' => 'ðŸŽ¯ ' . $field['label'] . ' (ACF)'
                            ];
                        }
                    }
                }
            }

            // Get custom fields from database (with safety checks)
            global $wpdb;
            if ($wpdb && $post_type->name !== 'game') { // Skip problematic post types
                $result = $wpdb->get_results($wpdb->prepare(
                    "SELECT DISTINCT meta_key FROM {$wpdb->posts}, {$wpdb->postmeta}
                     WHERE post_type = %s AND {$wpdb->posts}.ID = {$wpdb->postmeta}.post_id
                     AND meta_key NOT LIKE '\_%'
                     AND meta_key NOT LIKE 'field_%'
                     ORDER BY meta_key LIMIT 50", 
                     $post_type->name
                ), ARRAY_A);
                
                if ($result) {
                    foreach ($result as $a) {
                        if (!empty($a['meta_key']) && is_string($a['meta_key'])) {
                            $fields[$post_type->name][] = [
                                'value' => $a['meta_key'],
                                'label' => 'ðŸ”§ ' . $a['meta_key'] . ' (custom)'
                            ];
                        }
                    }
                }
            }

            // Sort fields by priority
            if (isset($fields[$post_type->name])) {
                usort($fields[$post_type->name], function($a, $b) {
                    $order = ['counter' => 1, 'post_title' => 2, 'post_content' => 3, 'featured_image' => 4];
                    $a_type = strpos($a['label'], '(built-in)') !== false ? $a['value'] : 'custom';
                    $b_type = strpos($b['label'], '(built-in)') !== false ? $b['value'] : 'custom';
                    
                    $a_priority = $order[$a_type] ?? 5;
                    $b_priority = $order[$b_type] ?? 5;
                    
                    if ($a_priority === $b_priority) {
                        return strcmp($a['label'], $b['label']);
                    }
                    return $a_priority - $b_priority;
                });
            }

            // Get taxonomies for this post type
            $taxonomy_objects = get_object_taxonomies($post_type->name, 'objects');
            $taxonomies[$post_type->name] = [];
            $taxonomies[$post_type->name][] = array('label' => 'Select Taxonomy', 'value' => '');
            
            foreach ($taxonomy_objects as $taxonomy_object) {
                $taxonomies[$post_type->name][] = array(
                    'label' => $taxonomy_object->label,
                    'value' => $taxonomy_object->name
                );

                $terms = get_terms(array(
                    'taxonomy' => $taxonomy_object->name,
                    'hide_empty' => true,
                    'number' => 50 // Limit terms
                ));
                
                if (!is_wp_error($terms)) {
                    $all_terms[$taxonomy_object->name] = [];
                    $all_terms[$taxonomy_object->name][] = array('label' => 'Select Term', 'value' => '');
                    
                    foreach ($terms as $term) {
                        if ($term->count > 0) {
                            $all_terms[$taxonomy_object->name][] = array(
                                'label' => $term->name . ' (' . $term->count . ')',
                                'value' => $term->slug
                            );
                        }
                    }
                }
            }

            // Get posts for manual selection (with limits)
            if ($post_type->name !== 'game') {
                $manual_posts = get_posts(array(
                    'post_type' => $post_type->name,
                    'posts_per_page' => 50, // Limit posts
                    'post_status' => 'publish',
                    'orderby' => 'title',
                    'order' => 'ASC'
                ));
                
                $manual_selection[$post_type->name] = [];
                foreach ($manual_posts as $manual_post) {
                    $manual_selection[$post_type->name][] = array(
                        'label' => $manual_post->post_title ?: 'Untitled',
                        'value' => $manual_post->ID
                    );
                }
            } else {
                $manual_selection[$post_type->name] = [];
            }
        }

        $return = array(
            'terms' => $all_terms,
            'taxonomies' => $taxonomies,
            'post_types' => $post_types,
            'manual_selection' => $manual_selection,
            'metafields' => $fields,
            'ajax_url' => admin_url('admin-ajax.php'),
        );

        error_log("METAFIELD: query_object_for_gutenberg_query completed successfully");
        return $return;
        
    } catch (Exception $e) {
        error_log("METAFIELD: Error in query_object_for_gutenberg_query: " . $e->getMessage());
        return array(
            'terms' => array(),
            'taxonomies' => array(),
            'post_types' => array(array('label' => 'Post', 'value' => 'post')),
            'manual_selection' => array('post' => array()),
            'metafields' => array('post' => array()),
            'ajax_url' => admin_url('admin-ajax.php'),
        );
    }
}


function stepfox_looks_count_views()
{
    $postID = get_the_ID();
    if (is_single()) {
        $count_key = 'stepfox_post_views_count';
        $count = get_post_meta($postID, $count_key, true);

        if ($count == '') {
            $count = 0;
            delete_post_meta($postID, $count_key);
            add_post_meta($postID, $count_key, '0');
        } else {
            $count++;
            update_post_meta($postID, $count_key, $count);
        }
    }
}

add_action("wp_head", "stepfox_looks_count_views");


//register the block
add_action("init", "examiner_register_metafield_block");


function examiner_register_metafield_block() {
    error_log("METAFIELD: examiner_register_metafield_block function called");
    
    wp_register_script("metafield-block-gutenberg",
        STEPFOX_LOOKS_URL . "blocks/metafield-block/metafield_block_gutenberg_fields.js",
        array("wp-blocks", "wp-editor", "wp-api", "jquery"), STEPFOX_LOOKS_VERSION, true
    );
    
    error_log("METAFIELD: About to call query_object_for_gutenberg_query");
    // the query object
    $query_controls_object = query_object_for_gutenberg_query();
    $query_controls_object["name"] = "";

    wp_localize_script("metafield-block-gutenberg", "metafield_block", $query_controls_object);

    // Register frontend script
    wp_register_script("metafield-block-script", STEPFOX_LOOKS_URL . "blocks/metafield-block/metafield_block_js.js", array(), STEPFOX_LOOKS_VERSION, true);
    // Register block styles
    wp_register_style("metafield-block-style", STEPFOX_LOOKS_URL . "blocks/metafield-block/metafield_block_css.css", array(), STEPFOX_LOOKS_VERSION);

    // Build attributes array properly instead of using problematic JSON decode
    $default_post_value = isset($query_controls_object["manual_selection"]["post"][0]["value"]) 
        ? $query_controls_object["manual_selection"]["post"][0]["value"] 
        : '';
        
    $attributes_reg = array(
        'style' => array(
            'type' => 'object',
            'default' => array(
                'elements' => array('link' => ''),
                'border' => array('radius' => '', 'style' => '', 'width' => ''),
                'color' => array(),
                'spacing' => array(
                    'blockGap' => '',
                    'margin' => array('top' => ''),
                    'padding' => array('top' => '')
                )
            )
        ),
        'post_type' => array('type' => 'string', 'default' => 'post'),
        'select_a_post_options' => array('type' => 'array', 'source' => 'attr', 'default' => array()),
        'select_a_post' => array('type' => 'string', 'default' => $default_post_value),
        'custom_css' => array('type' => 'string', 'default' => ''),
        'align' => array('type' => 'string', 'default' => 'wide'),
        'backgroundColor' => array('type' => 'string', 'default' => ''),
        'gradient' => array('type' => 'string', 'default' => ''),
        'linkColor' => array('type' => 'string', 'default' => ''),
        'textColor' => array('type' => 'string', 'default' => ''),
        'fontSize' => array('type' => 'string', 'default' => ''),
        'fontFamily' => array('type' => 'string', 'default' => ''),
        'fontWeight' => array('type' => 'string', 'default' => ''),
        'fontStyle' => array('type' => 'string', 'default' => ''),
        'textTransform' => array('type' => 'string', 'default' => ''),
        'letterSpacing' => array('type' => 'string', 'default' => ''),
        'meta_field' => array('type' => 'string', 'default' => ''),
        'borderColor' => array('type' => 'string', 'default' => ''),
        'element_type' => array('type' => 'string', 'default' => 'p'),
        'layout' => array('type' => 'object', 'default' => array()),
        'customId' => array('type' => 'string', 'default' => 'stepfox-not-set-id')
    );
    
    // Remove the duplicate customId addition since it's now in the main array

    register_block_type(
        "examiner/metafield-block", array(
            "render_callback" => "examiner_render_metafield_block",
            "category" => "examiner",
            "attributes" => $attributes_reg,
            "style" => "metafield-block-style",//ova e backend i frontend za blockot
            "script" => "metafield-block-script", //i back i front
            "editor_script" => "metafield-block-gutenberg",
            "editor_style" => "metafield-block-style",
        )
    );
    
    error_log("METAFIELD: Block registration completed");
}
?>
